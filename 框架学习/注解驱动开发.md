# 一. IOC

## 1. 配置类

```java
//定义配置类
@Configuration
//开启组件扫描，可以指定选择或者排除规则
//includeFilters = Filter[]
//excludeFilters = Filter[]
//FilterType.ANNOTATION: 按照注解
//FilterType.ASSIGNABLE_TYPE: 按照类型
//FilterType.ASPECTJ: 使用ASPECTJ表达式
//FilterType.REGEX: 使用正则表达式
//FilterType.CUSTOM: 使用自定义规则
@ComponentScan(value = "com.atlff",excludeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
})
public class MainConfig {
    //在容器中注册Bean，class为返回值的类型，默认方法名为id
    @Bean("psersion")
    public Persion persion(){
        return new Persion("lff",12);
    }
}
```

自定义过滤规则：

返回true时为匹配成功。

```java
public class MyTypeFilter implements TypeFilter {
    /**
     *
     * @param metadataReader 读取到当前正在扫描类的信息
     * @param metadataReaderFactory 可以获取到其他任何类的信息
     * for other classes (such as superclasses and interfaces)
     * @return
     * @throws IOException
     */
    @Override
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
        //获取当前类的注解信息
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();
        //获取当前正在扫描的类的信息
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        //获取当前类的资源信息(类的路径)
        Resource resource = metadataReader.getResource();

        String className = classMetadata.getClassName();
        System.out.println("className = " + className);
        return className.contains("er");
    }
}
```

## 2. 注册Bean

### 2.1 配置扫描+注解

@Controller，@Service，@Repository，@Component等

### 2.2 使用@Bean标签【导入第三方包的组件】

```java
/**
     * singleton：单实例，默认，容器启动时创建对象
     *      懒加载：@LAZY
     * prototype：多实例，调用时才创建对象
     * SCOPE_REQUEST：同一次请求创建一个实例
     * SCOPE_SESSION：同一次session创建一次实例
     */
@Conditional({WindowsCondition.class})
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Bean(value = "lff")
public Persion persion(){
    return new Persion("lff",20);
}
```

Condition过滤条件的实现类：

```java
public class WindowsCondition implements Condition {
    /**
     *
     * @param context the condition context
     * @param metadata the metadata of the {@link org.springframework.core.type.AnnotationMetadata class}
     * or {@link org.springframework.core.type.MethodMetadata method} being checked
     * @return
     */
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        //获取到ioc的beanfactory
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
        //获取到类加载器
        ClassLoader classLoader = context.getClassLoader();
        //获取到当前环境信息
        Environment environment = context.getEnvironment();
        //获取到bean定义的注册类
        BeanDefinitionRegistry registry = context.getRegistry();


        String osName = environment.getProperty("os.name");
        if(osName.contains("Windows")){
            return true;
        }
        return false;
    }
}
```

### 2.3 `@Import{clazz}`【快速导入第三方组件到容器中】

id默认是包的全类名

```java
@Import({Color.class,MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})
public class MainConfig2 {
}
```

- 使用`ImportSelector`接口实现类

```java
public class MyImportSelector implements ImportSelector {
    /**
     * @param importingClassMetadata 当前标注@Import类的左右注解信息
     */
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{"com.atlff.bean.Blue","com.atlff.bean.Red"};
    }
}
```

- 使用`ImportBeanDefinitionRegistrar`接口实现类

```java
public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    /**
     * @param importingClassMetadata annotation metadata of the importing class
     * @param registry current bean definition registry
     *                 把需要添加到容器的类，用registry.registerBeanDefinition()注册
     */
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        boolean red = registry.containsBeanDefinition("com.atlff.bean.Red");
        boolean blue = registry.containsBeanDefinition("com.atlff.bean.Blue");
        RootBeanDefinition beanDefinition = new RootBeanDefinition(Rainbow.class);
        if(red & blue){
            registry.registerBeanDefinition("rainbow", beanDefinition);
        }
        ImportBeanDefinitionRegistrar.super.registerBeanDefinitions(importingClassMetadata, registry);
    }
}
```

### 2.4 FactoryBean工厂类

创建bean：

```java
public class ColorFactoryBean implements FactoryBean<Color> {
    //返回一个Color对象，添加到容器中
    @Override
    public Color getObject() throws Exception {
        System.out.println("ColorFactoryBean...getObject...");
        return new Color();
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
```

调用bean：

```java
@Test
public void test03(){
    System.out.println("=============================");
    //获取工厂类生产的bean
    Object bean1 = applicationContextcontext.getBean("colorFactoryBean");
    System.out.println("colorFactoryBean的类型 = " + bean1.getClass());

    //获取工厂类本身bean
    Object bean2 = applicationContextcontext.getBean("&colorFactoryBean");
    System.out.println("colorFactoryBean的类型 = " + bean2.getClass());

}
```

## 3. Bean的生命周期

### 1. 初始化和销毁

1. 方式一：注解@Bean

```java
@Configuration
public class MainConfigOfLifeCycle {
    @Bean(initMethod = "init",destroyMethod = "destory")
    public Car car(){
        return new Car();
    }
}


public class Car {
    public Car(){
        System.out.println("Car constructor ...");
    }

    public void init(){
        System.out.println("Car init ...");
    }

    public void destory(){
        System.out.println("Car destory ...");
    }
}
```

2. 方式二：接口

```java
@Component
public class Cat implements InitializingBean, DisposableBean {
    public Cat(){
        System.out.println("Cat constructor...");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("Cat destroy...");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("Cat afterPropertiesSet...");
    }
}
```

3. 使用JSR250的注解：构造后`@PostConstruct`和销毁前`@PreDestroy`

```java
@Component
public class Dog {
    public Dog(){
        System.out.println("Dog constructor...");
    }

    //对象创建完成并且赋值之后
    @PostConstruct
    public void init() {
        System.out.println("Dog @PostConstruct...");
    }

    //销毁之前调用
    @PreDestroy
    public void destory() {
        System.out.println("Dog @PreDestroy...");
    }
}
```

4. 初始化前后：接口`BeanPostProcessor`

```java
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization..." + beanName + "==>" + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization..." + beanName + "==>" + bean);
        return bean;
    }
}
```

### 2. 执行原理

```
 * BeanPostProcessor原理
 * populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值
 * initializeBean
 * {
 * applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
 * invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化
 * applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
 * }
```

## 4.属性注入

在bean对应类的属性使用`@Value`属性

值的类型：

1. 基本数值

2. 可以使用SpEL：#{}，eg：#{20-2}

3. 可以写${}，取出配置文件【properties】中的值（在运行环境变量里的值）

    在配置类添加注解：

    `@PropertySource(value = "classpath:/person.properties",encoding = "UTF-8")`

    使用"@Value(\"\$\{person.nickName\}\")"

    